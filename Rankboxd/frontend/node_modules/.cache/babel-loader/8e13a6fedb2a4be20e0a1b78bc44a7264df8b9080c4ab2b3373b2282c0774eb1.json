{"ast":null,"code":"var _jsxFileName = \"/Users/kilianreichl/RBDev/rankboxd/src/App.js\",\n  _s = $RefreshSig$();\n// App.js\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport InputForm from './components/InputForm';\nimport RankingProcess from './components/RankingProcess';\nimport MovieResults from './components/Results';\nimport ProgressBar from './components/ProgressBar';\nimport ModeSelection from './components/ModeSelection';\nimport StatusBar from './components/StatusBar';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CONFIDENCE_SCALING = {\n  BASE_THRESHOLD: 0.7,\n  MIN_DATASET: 10,\n  MAX_DATASET: 500,\n  EARLY_STAGE_MULTIPLIER: 0.8,\n  LATE_STAGE_MULTIPLIER: 1.2,\n  MIN_ALLOWED_THRESHOLD: 0.5,\n  MAX_ALLOWED_THRESHOLD: 0.9\n};\nconst CONFIDENCE_CONSTANTS = {\n  MIN_COMPARISONS: 3,\n  OPTIMAL_COMPARISONS: 5,\n  LOCAL_RANGE: 3,\n  RECENT_WEIGHT: 0.6,\n  HISTORICAL_WEIGHT: 0.4,\n  POSITION_WEIGHTS: {\n    TOP: 0.8,\n    // Expect more consistent wins\n    MIDDLE: 0.5,\n    // Mixed results are okay\n    BOTTOM: 0.8 // Expect more consistent losses\n  },\n  TRANSITIVITY_WEIGHT: 0.3,\n  COMPARISON_QUALITY_WEIGHT: 0.2\n};\nconst calculateAdaptiveThresholds = (movieCount, progress) => {\n  // Calculate base scaling factor based on dataset size\n  const sizeFactor = Math.min(Math.max((movieCount - CONFIDENCE_SCALING.MIN_DATASET) / (CONFIDENCE_SCALING.MAX_DATASET - CONFIDENCE_SCALING.MIN_DATASET), 0), 1);\n\n  // Adjust base threshold based on dataset size\n  // Smaller datasets need higher confidence thresholds\n  const baseThreshold = CONFIDENCE_SCALING.BASE_THRESHOLD * (1 - sizeFactor * 0.3);\n\n  // Calculate progress-based thresholds\n  const progressMultiplier = progress < 0.3 ? CONFIDENCE_SCALING.EARLY_STAGE_MULTIPLIER : progress > 0.7 ? CONFIDENCE_SCALING.LATE_STAGE_MULTIPLIER : 1;\n\n  // Calculate final threshold with bounds\n  const adaptiveThreshold = Math.min(Math.max(baseThreshold * progressMultiplier, CONFIDENCE_SCALING.MIN_ALLOWED_THRESHOLD), CONFIDENCE_SCALING.MAX_ALLOWED_THRESHOLD);\n  return {\n    confidence: adaptiveThreshold,\n    stability: adaptiveThreshold * 0.8,\n    transitivity: adaptiveThreshold * 0.9,\n    rankChange: Math.max(0.02, 0.05 * (1 - sizeFactor))\n  };\n};\nconst calculateLocalTransitivity = (movieId, rankings, sortedMovies, position) => {\n  const localRange = CONFIDENCE_CONSTANTS.LOCAL_RANGE;\n  const start = Math.max(0, position - localRange);\n  const end = Math.min(sortedMovies.length, position + localRange + 1);\n  const localMovies = sortedMovies.slice(start, end);\n  let weightedTransitivity = 0;\n  let totalWeight = 0;\n  for (let i = 0; i < localMovies.length - 2; i++) {\n    for (let j = i + 1; j < localMovies.length - 1; j++) {\n      for (let k = j + 1; k < localMovies.length; k++) {\n        const [a, b, c] = [localMovies[i], localMovies[j], localMovies[k]].map(m => m.movie.identifier);\n\n        // Calculate positional weight (closer positions matter more)\n        const posWeight = 1 / (Math.abs(position - i) + 1);\n\n        // Calculate rating difference weight\n        const ratingDiffs = Math.abs(rankings[a].rating - rankings[b].rating) + Math.abs(rankings[b].rating - rankings[c].rating) + Math.abs(rankings[a].rating - rankings[c].rating);\n        const ratingWeight = 1 / (1 + ratingDiffs);\n        const weight = posWeight * ratingWeight;\n        if (rankings[a].recentResults.some(r => r.opponent === b || r.opponent === c) && rankings[b].recentResults.some(r => r.opponent === c)) {\n          totalWeight += weight;\n          if (rankings[a].rating > rankings[b].rating && rankings[b].rating > rankings[c].rating && rankings[a].rating > rankings[c].rating || rankings[c].rating > rankings[b].rating && rankings[b].rating > rankings[a].rating && rankings[c].rating > rankings[a].rating) {\n            weightedTransitivity += weight;\n          }\n        }\n      }\n    }\n  }\n  return totalWeight > 0 ? weightedTransitivity / totalWeight : 0.5;\n};\nconst calculateEnhancedConfidence = (movieId, rankings, allMovies) => {\n  const record = rankings[movieId];\n  if (!record || record.comparisons < CONFIDENCE_CONSTANTS.MIN_COMPARISONS) {\n    return 0.2; // Minimum baseline confidence of 20%\n  }\n\n  // 1. Base Comparison Confidence (0-1)\n  const comparisonScore = Math.min(record.comparisons / CONFIDENCE_CONSTANTS.OPTIMAL_COMPARISONS, 1) * 0.8 + 0.2; // Minimum 20% if at least MIN_COMPARISONS\n\n  // 2. Position-Aware Consistency (0-1)\n  const sortedMovies = Object.values(rankings).sort((a, b) => b.rating - a.rating);\n  const position = sortedMovies.findIndex(r => r.movie.identifier === movieId);\n  const relativePosition = position / sortedMovies.length;\n  let expectedWinRate, positionWeight;\n  if (relativePosition <= 0.25) {\n    expectedWinRate = 0.75; // Top 25% should win most\n    positionWeight = CONFIDENCE_CONSTANTS.POSITION_WEIGHTS.TOP;\n  } else if (relativePosition >= 0.75) {\n    expectedWinRate = 0.25; // Bottom 25% should lose most\n    positionWeight = CONFIDENCE_CONSTANTS.POSITION_WEIGHTS.BOTTOM;\n  } else {\n    expectedWinRate = 0.5; // Middle 50% can be mixed\n    positionWeight = CONFIDENCE_CONSTANTS.POSITION_WEIGHTS.MIDDLE;\n  }\n  const actualWinRate = record.wins / record.comparisons;\n  const consistencyScore = (1 - Math.abs(actualWinRate - expectedWinRate)) * positionWeight;\n\n  // 3. Local Performance (0-1)\n  const neighbors = sortedMovies.slice(Math.max(0, position - CONFIDENCE_CONSTANTS.LOCAL_RANGE), Math.min(sortedMovies.length, position + CONFIDENCE_CONSTANTS.LOCAL_RANGE + 1)).map(r => r.movie.identifier).filter(id => id !== movieId);\n  const localComparisons = record.recentResults.filter(r => neighbors.includes(r.opponent));\n  const localConsistencyScore = localComparisons.length > 0 ? localComparisons.reduce((sum, r) => sum + (r.result === (r.opponent.rating < record.rating ? 1 : 0)), 0) / localComparisons.length : 0.5;\n\n  // 4. Temporal Confidence (0-1)\n  const recentResults = record.recentResults.slice(-5);\n  const historicalResults = record.recentResults.slice(0, -5);\n  const calculateResultsConsistency = results => {\n    if (results.length < 2) return 0.5;\n    let flips = 0;\n    for (let i = 1; i < results.length; i++) {\n      if (results[i].result !== results[i - 1].result) flips++;\n    }\n    return 1 - flips / (results.length - 1);\n  };\n  const recentConsistency = calculateResultsConsistency(recentResults);\n  const historicalConsistency = calculateResultsConsistency(historicalResults);\n  const temporalConsistency = recentConsistency * CONFIDENCE_CONSTANTS.RECENT_WEIGHT + historicalConsistency * CONFIDENCE_CONSTANTS.HISTORICAL_WEIGHT;\n\n  // 5. Transitivity Score (0-1)\n  const transitivityScore = calculateLocalTransitivity(movieId, rankings, sortedMovies, position);\n\n  // Combine all factors with weights\n  const finalConfidence = comparisonScore * 0.25 + consistencyScore * 0.20 + localConsistencyScore * 0.25 + temporalConsistency * 0.15 + transitivityScore * CONFIDENCE_CONSTANTS.TRANSITIVITY_WEIGHT;\n\n  // Ensure minimum confidence of 20% and maximum of 100%\n  return Math.min(Math.max(finalConfidence, 0.2), 1);\n};\nconst calculateComparisonImpact = (movieA, movieB, rankings, progress) => {\n  // Don't show impact indicators too early\n  if (progress < 0.2) return false;\n  const recordA = rankings[movieA.identifier];\n  const recordB = rankings[movieB.identifier];\n\n  // Calculate rating uncertainty\n  const ratingDiff = Math.abs(recordA.rating - recordB.rating);\n  const avgComparisons = (recordA.comparisons + recordB.comparisons) / 2;\n  const uncertaintyScore = 1 / (avgComparisons + 1);\n\n  // More impactful if:\n  // 1. Movies are close in rating\n  // 2. We don't have many comparisons yet\n  // 3. We're in the middle phase of ranking (20%-80%)\n  const ratingProximity = 1 / (1 + Math.exp(5 * (ratingDiff - 0.5)));\n  const phaseImportance = 1 - Math.abs(progress - 0.5) * 2;\n  const impactScore = ratingProximity * 0.5 + uncertaintyScore * 0.3 + phaseImportance * 0.2;\n\n  // Return true if this is a high-impact comparison\n  return impactScore > 0.7;\n};\nfunction App() {\n  _s();\n  const [movies, setMovies] = useState([]);\n  const [rankings, setRankings] = useState({});\n  const [step, setStep] = useState('input');\n  const [comparisons, setComparisons] = useState(0);\n  const [maxComparisons, setMaxComparisons] = useState(0);\n  const [pendingUpdates, setPendingUpdates] = useState([]);\n  const [recentChanges, setRecentChanges] = useState([]);\n  const [comparisonHistory, setComparisonHistory] = useState([]);\n  const [movieMomentum, setMovieMomentum] = useState({});\n  const [isCurrentComparisonHighImpact, setIsCurrentComparisonHighImpact] = useState(false);\n  const CONVERGENCE_CHECK_WINDOW = 10;\n  const BASE_LEARNING_RATE = 0.1;\n  const VOLATILITY_WINDOW = 20; // How many recent changes to consider\n  const VOLATILITY_THRESHOLD_HIGH = 0.05; // High volatility threshold\n  const VOLATILITY_THRESHOLD_LOW = 0.01; // Low volatility threshold\n\n  const MOMENTUM_FACTOR = 0.9;\n  const MIN_LEARNING_RATE = 0.01;\n  const MAX_LEARNING_RATE = 0.2;\n  const EARLY_TERMINATION = {\n    MIN_PROGRESS: 0.4,\n    // Don't terminate before 40% completion\n    MIN_COMPARISONS_PER_MOVIE: 5,\n    MIN_CONFIDENCE_THRESHOLD: 0.7,\n    STABILITY_WINDOW: 15,\n    STABILITY_THRESHOLD: 0.03,\n    MIN_TRANSITIVITY_SCORE: 0.85,\n    RELATIVE_RANK_STABILITY: 0.9\n  };\n  const calculateConfidence = useCallback(movieId => {\n    return calculateEnhancedConfidence(movieId, rankings, movies);\n  }, [rankings, movies]);\n  const calculateBatchParameters = useCallback(movieCount => {\n    const scalingFactor = Math.log2(movieCount) / Math.log2(100);\n\n    // Calculate base sizes\n    const baseSizes = {\n      EARLY_STAGE_SIZE: Math.min(8, Math.max(2, Math.floor(movieCount * 0.03 * scalingFactor))),\n      MID_STAGE_SIZE: Math.min(12, Math.max(3, Math.floor(movieCount * 0.06 * scalingFactor))),\n      LATE_STAGE_SIZE: Math.min(20, Math.max(4, Math.floor(movieCount * 0.1 * scalingFactor))),\n      EARLY_STAGE_THRESHOLD: 0.15 + 0.05 * (1 - scalingFactor),\n      LATE_STAGE_THRESHOLD: 0.65 + 0.1 * scalingFactor,\n      MIN_CONFIDENCE_THRESHOLD: 0.35 + 0.1 * scalingFactor\n    };\n\n    // Calculate volatility factor based on recent rating changes\n    const calculateVolatility = () => {\n      if (recentChanges.length < VOLATILITY_WINDOW) {\n        return 1; // Default to normal batch size if not enough data\n      }\n\n      // Calculate average magnitude of recent rating changes\n      const recentVolatility = recentChanges.slice(-VOLATILITY_WINDOW).reduce((sum, change) => sum + Math.abs(change), 0) / VOLATILITY_WINDOW;\n\n      // Convert volatility to a scaling factor between 0.5 and 1.5\n      if (recentVolatility > VOLATILITY_THRESHOLD_HIGH) {\n        return 0.5; // High volatility = smaller batches\n      } else if (recentVolatility < VOLATILITY_THRESHOLD_LOW) {\n        return 1.5; // Low volatility = larger batches\n      } else {\n        // Linear interpolation between thresholds\n        return 1 + (VOLATILITY_THRESHOLD_HIGH - recentVolatility) / (VOLATILITY_THRESHOLD_HIGH - VOLATILITY_THRESHOLD_LOW);\n      }\n    };\n    const volatilityFactor = calculateVolatility();\n\n    // Apply volatility factor to batch sizes\n    return {\n      ...baseSizes,\n      EARLY_STAGE_SIZE: Math.max(2, Math.round(baseSizes.EARLY_STAGE_SIZE * volatilityFactor)),\n      MID_STAGE_SIZE: Math.max(3, Math.round(baseSizes.MID_STAGE_SIZE * volatilityFactor)),\n      LATE_STAGE_SIZE: Math.max(4, Math.round(baseSizes.LATE_STAGE_SIZE * volatilityFactor))\n    };\n  }, [recentChanges]);\n  const startRanking = useCallback(movieList => {\n    console.log(`Starting ranking process with ${movieList.length} movies`);\n    const initialRankings = movieList.reduce((acc, movie) => {\n      acc[movie.identifier] = {\n        rating: 0,\n        movie: movie,\n        wins: 0,\n        losses: 0,\n        comparisons: 0,\n        recentResults: [],\n        // Will store objects with opponent and result info\n        confidenceScore: 0,\n        uncertainty: 0\n      };\n      return acc;\n    }, {});\n    setMovies(movieList);\n    setRankings(initialRankings);\n    setStep('mode-selection');\n  }, []);\n  const selectMode = (mode, comparisonsCount) => {\n    setMaxComparisons(comparisonsCount);\n    setStep('ranking');\n  };\n  const finishRanking = useCallback(() => {\n    console.log(\"Finishing ranking process\");\n    setTimeout(() => {\n      setStep('results');\n    }, 0);\n  }, []);\n  const handleUndo = useCallback(() => {\n    if (comparisonHistory.length > 0) {\n      const newHistory = [...comparisonHistory];\n      const lastComparison = newHistory.pop();\n      setComparisonHistory(newHistory);\n      setComparisons(prev => Math.max(0, prev - 1));\n\n      // Clear any pending updates\n      setPendingUpdates([]);\n\n      // Reset the rankings to the previous state and provide the previous pair\n      if (lastComparison) {\n        setRankings(lastComparison.rankings);\n        // Reset recent changes since we're going back\n        setRecentChanges([]);\n        return lastComparison.pair; // Return the previous pair\n      }\n    }\n    return null;\n  }, [comparisonHistory]);\n  const checkTransitivityViolation = useCallback((winner, loser) => {\n    const winnerRating = rankings[winner].rating;\n    const loserRating = rankings[loser].rating;\n\n    // If the winner's current rating is lower, this is a transitivity violation\n    if (winnerRating < loserRating) {\n      console.log(`Transitivity violation detected: ${winner} (${winnerRating}) beat ${loser} (${loserRating})`);\n      return true;\n    }\n    return false;\n  }, [rankings]);\n  const getDynamicLearningRate = useCallback((winner, loser) => {\n    const progress = comparisons / maxComparisons;\n    const ratingDiff = Math.abs(rankings[winner].rating - rankings[loser].rating);\n    const winnerConfidence = calculateConfidence(winner);\n    const loserConfidence = calculateConfidence(loser);\n\n    // Start with base learning rate\n    let learningRate = BASE_LEARNING_RATE;\n\n    // Adjust based on progress\n    learningRate *= 1 - progress * 0.5;\n\n    // Adjust for rating difference\n    const surpriseFactor = 1 / (1 + Math.exp(-5 * (1 - ratingDiff)));\n    learningRate *= 1 + surpriseFactor;\n\n    // Confidence adjustment\n    const confidenceFactor = 1 - (winnerConfidence + loserConfidence) / 4;\n    learningRate *= confidenceFactor;\n\n    // Transitivity violation adjustment\n    if (checkTransitivityViolation(winner, loser)) {\n      learningRate *= 1.5;\n    }\n\n    // Apply momentum if available\n    const winnerMomentum = movieMomentum[winner] || 0;\n    const loserMomentum = movieMomentum[loser] || 0;\n    const avgMomentum = (Math.abs(winnerMomentum) + Math.abs(loserMomentum)) / 2;\n    learningRate *= 1 + avgMomentum * MOMENTUM_FACTOR;\n\n    // Clamp learning rate\n    return Math.max(MIN_LEARNING_RATE, Math.min(MAX_LEARNING_RATE, learningRate));\n  }, [comparisons, maxComparisons, rankings, checkTransitivityViolation, calculateConfidence, movieMomentum]);\n  const calculateOptimalBatchSize = useCallback(() => {\n    const movieCount = movies.length;\n    const batchParams = calculateBatchParameters(movieCount);\n    const progress = comparisons / maxComparisons;\n\n    // Calculate average confidence across all movies\n    const avgConfidence = Object.values(rankings).reduce((sum, record) => {\n      return sum + (record && record.movie ? calculateConfidence(record.movie.identifier) : 0);\n    }, 0) / movieCount;\n    console.log(`Current batch parameters for ${movieCount} movies:`, {\n      early: batchParams.EARLY_STAGE_SIZE,\n      mid: batchParams.MID_STAGE_SIZE,\n      late: batchParams.LATE_STAGE_SIZE,\n      progress: progress.toFixed(2),\n      avgConfidence: avgConfidence.toFixed(2)\n    });\n\n    // Determine stage based on progress\n    if (progress < batchParams.EARLY_STAGE_THRESHOLD) {\n      return batchParams.EARLY_STAGE_SIZE;\n    } else if (progress > batchParams.LATE_STAGE_THRESHOLD) {\n      return batchParams.LATE_STAGE_SIZE;\n    } else {\n      return avgConfidence < batchParams.MIN_CONFIDENCE_THRESHOLD ? batchParams.EARLY_STAGE_SIZE : batchParams.MID_STAGE_SIZE;\n    }\n  }, [movies.length, comparisons, maxComparisons, rankings, calculateConfidence,\n  // Add this\n  calculateBatchParameters]);\n  const calculateTransitivityScore = useCallback(() => {\n    let transitiveTriads = 0;\n    let totalTriads = 0;\n\n    // Get sorted movies by rating\n    const sortedMovies = Object.values(rankings).sort((a, b) => b.rating - a.rating).map(r => r.movie.identifier);\n\n    // Check random sample of triads for transitivity\n    const sampleSize = Math.min(1000, Math.floor(sortedMovies.length * (sortedMovies.length - 1) * (sortedMovies.length - 2) / 6));\n    for (let i = 0; i < sampleSize; i++) {\n      const idx1 = Math.floor(Math.random() * sortedMovies.length);\n      const idx2 = Math.floor(Math.random() * sortedMovies.length);\n      const idx3 = Math.floor(Math.random() * sortedMovies.length);\n      if (idx1 !== idx2 && idx2 !== idx3 && idx1 !== idx3) {\n        totalTriads++;\n        const [a, b, c] = [sortedMovies[idx1], sortedMovies[idx2], sortedMovies[idx3]].sort((x, y) => rankings[y].rating - rankings[x].rating);\n        if (rankings[a].rating > rankings[b].rating && rankings[b].rating > rankings[c].rating && rankings[a].rating > rankings[c].rating) {\n          transitiveTriads++;\n        }\n      }\n    }\n    return totalTriads > 0 ? transitiveTriads / totalTriads : 0;\n  }, [rankings]);\n  const calculateRankStability = useCallback(() => {\n    if (comparisonHistory.length < EARLY_TERMINATION.STABILITY_WINDOW) {\n      return 0;\n    }\n    const currentRanking = Object.values(rankings).sort((a, b) => b.rating - a.rating).map(r => r.movie.identifier);\n    const previousRanking = Object.values(comparisonHistory[comparisonHistory.length - EARLY_TERMINATION.STABILITY_WINDOW].rankings).sort((a, b) => b.rating - a.rating).map(r => r.movie.identifier);\n    let stabilityScore = 0;\n    const totalMovies = currentRanking.length;\n    for (let i = 0; i < totalMovies; i++) {\n      const previousIndex = previousRanking.indexOf(currentRanking[i]);\n      const positionWeight = 1 - i / totalMovies; // Top positions matter more\n      const maxPossibleDiff = totalMovies - 1;\n      const actualDiff = Math.abs(i - previousIndex);\n      const positionStability = 1 - actualDiff / maxPossibleDiff;\n      stabilityScore += positionStability * positionWeight;\n    }\n    return stabilityScore / totalMovies;\n  }, [rankings, comparisonHistory, EARLY_TERMINATION.STABILITY_WINDOW]);\n  const checkRankingStability = useCallback(() => {\n    const progress = comparisons / maxComparisons;\n    const adaptiveThresholds = calculateAdaptiveThresholds(movies.length, progress);\n\n    // Don't check before minimum progress\n    if (comparisons / maxComparisons < EARLY_TERMINATION.MIN_PROGRESS) {\n      return false;\n    }\n\n    // Check minimum comparisons per movie\n    const insufficientComparisons = Object.values(rankings).some(record => record.comparisons < EARLY_TERMINATION.MIN_COMPARISONS_PER_MOVIE);\n    if (insufficientComparisons) {\n      return false;\n    }\n\n    // Calculate average confidence with adaptive threshold\n    const avgConfidence = Object.values(rankings).reduce((sum, record) => sum + calculateConfidence(record.movie.identifier), 0) / movies.length;\n    if (avgConfidence < Math.max(adaptiveThresholds.confidence, EARLY_TERMINATION.MIN_CONFIDENCE_THRESHOLD)) {\n      return false;\n    }\n\n    // Check recent stability with adaptive threshold\n    if (recentChanges.length < EARLY_TERMINATION.STABILITY_WINDOW) {\n      return false;\n    }\n    const recentInstability = recentChanges.slice(-EARLY_TERMINATION.STABILITY_WINDOW).some(change => Math.abs(change) > Math.min(adaptiveThresholds.rankChange, EARLY_TERMINATION.STABILITY_THRESHOLD));\n    if (recentInstability) {\n      return false;\n    }\n\n    // Check transitivity with adaptive threshold\n    const transitivityScore = calculateTransitivityScore();\n    if (transitivityScore < Math.max(adaptiveThresholds.transitivity, EARLY_TERMINATION.MIN_TRANSITIVITY_SCORE)) {\n      return false;\n    }\n\n    // Check relative rank stability with adaptive threshold\n    const rankStability = calculateRankStability();\n    if (rankStability < Math.max(adaptiveThresholds.stability, EARLY_TERMINATION.RELATIVE_RANK_STABILITY)) {\n      return false;\n    }\n    console.log('Early termination conditions met:', {\n      progress: (comparisons / maxComparisons).toFixed(2),\n      avgConfidence: avgConfidence.toFixed(2),\n      transitivityScore: transitivityScore.toFixed(2),\n      rankStability: rankStability.toFixed(2),\n      adaptiveThresholds: {\n        confidence: adaptiveThresholds.confidence.toFixed(2),\n        stability: adaptiveThresholds.stability.toFixed(2),\n        transitivity: adaptiveThresholds.transitivity.toFixed(2),\n        rankChange: adaptiveThresholds.rankChange.toFixed(3)\n      }\n    });\n    return true;\n  }, [movies.length, comparisons, maxComparisons, rankings, recentChanges, calculateConfidence, calculateTransitivityScore, calculateRankStability, EARLY_TERMINATION.MIN_PROGRESS, EARLY_TERMINATION.MIN_COMPARISONS_PER_MOVIE, EARLY_TERMINATION.MIN_CONFIDENCE_THRESHOLD, EARLY_TERMINATION.STABILITY_WINDOW, EARLY_TERMINATION.STABILITY_THRESHOLD, EARLY_TERMINATION.MIN_TRANSITIVITY_SCORE, EARLY_TERMINATION.RELATIVE_RANK_STABILITY]);\n  const checkConvergence = useCallback(() => {\n    if (checkRankingStability()) {\n      console.log(\"Rankings have converged with high confidence - finishing early\");\n      finishRanking();\n    }\n  }, [checkRankingStability, finishRanking]);\n  const processBatchUpdate = useCallback(updates => {\n    setRankings(prevRankings => {\n      const newRankings = {\n        ...prevRankings\n      };\n      const newMomentum = {\n        ...movieMomentum\n      };\n      updates.forEach(({\n        winner,\n        loser\n      }) => {\n        const learningRate = getDynamicLearningRate(winner, loser);\n        const winnerStrength = Math.exp(prevRankings[winner].rating);\n        const loserStrength = Math.exp(prevRankings[loser].rating);\n        const expectedProbWinner = winnerStrength / (winnerStrength + loserStrength);\n        const ratingChange = learningRate * (1 - expectedProbWinner);\n\n        // Update momentum\n        newMomentum[winner] = (newMomentum[winner] || 0) * MOMENTUM_FACTOR + ratingChange;\n        newMomentum[loser] = (newMomentum[loser] || 0) * MOMENTUM_FACTOR - ratingChange;\n\n        // Update ratings with momentum influence and store opponent info\n        newRankings[winner] = {\n          ...newRankings[winner],\n          rating: prevRankings[winner].rating + ratingChange + newMomentum[winner] * MOMENTUM_FACTOR,\n          wins: prevRankings[winner].wins + 1,\n          comparisons: prevRankings[winner].comparisons + 1,\n          recentResults: [...prevRankings[winner].recentResults.slice(-9), {\n            opponent: loser,\n            result: 1,\n            ratingDiff: Math.abs(prevRankings[winner].rating - prevRankings[loser].rating)\n          }]\n        };\n        newRankings[loser] = {\n          ...newRankings[loser],\n          rating: prevRankings[loser].rating - ratingChange + newMomentum[loser] * MOMENTUM_FACTOR,\n          losses: prevRankings[loser].losses + 1,\n          comparisons: prevRankings[loser].comparisons + 1,\n          recentResults: [...prevRankings[loser].recentResults.slice(-9), {\n            opponent: winner,\n            result: 0,\n            ratingDiff: Math.abs(prevRankings[winner].rating - prevRankings[loser].rating)\n          }]\n        };\n        setRecentChanges(prev => [...prev.slice(-CONVERGENCE_CHECK_WINDOW + 1), ratingChange]);\n      });\n      setMovieMomentum(newMomentum);\n      return newRankings;\n    });\n    checkConvergence();\n  }, [getDynamicLearningRate, checkConvergence, movieMomentum]);\n  const updateRankings = useCallback((winnerIdentifier, loserIdentifier, currentPair) => {\n    // Save current state to history\n    setComparisonHistory(prev => [...prev, {\n      winner: winnerIdentifier,\n      loser: loserIdentifier,\n      rankings: {\n        ...rankings\n      },\n      pair: currentPair // Use currentPair instead of pair\n    }]);\n\n    // Calculate progress for impact determination\n    const progress = comparisons / maxComparisons;\n\n    // Calculate impact before updating rankings\n    const isHighImpact = calculateComparisonImpact(rankings[winnerIdentifier], rankings[loserIdentifier], rankings, progress);\n\n    // Add to pending updates and process if optimal batch size reached\n    setPendingUpdates(prev => {\n      const newPending = [...prev, {\n        winner: winnerIdentifier,\n        loser: loserIdentifier\n      }];\n      const optimalBatchSize = calculateOptimalBatchSize();\n      if (newPending.length >= optimalBatchSize) {\n        console.log(`Processing batch of size ${optimalBatchSize}`);\n        processBatchUpdate(newPending);\n        return [];\n      }\n      return newPending;\n    });\n    setComparisons(prev => prev + 1);\n  }, [rankings, processBatchUpdate, calculateOptimalBatchSize, comparisons, maxComparisons]);\n  useEffect(() => {\n    if (step === 'results' && pendingUpdates.length > 0) {\n      processBatchUpdate(pendingUpdates);\n      setPendingUpdates([]);\n    }\n  }, [step, pendingUpdates, processBatchUpdate]);\n  const memoizedRankingProcess = useMemo(() => /*#__PURE__*/_jsxDEV(RankingProcess, {\n    movies: movies,\n    rankings: rankings,\n    comparisons: comparisons,\n    maxComparisons: maxComparisons,\n    calculateConfidence: calculateConfidence,\n    onChoose: updateRankings,\n    onFinish: finishRanking,\n    onUndo: handleUndo\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 709,\n    columnNumber: 5\n  }, this), [movies, rankings, comparisons, maxComparisons, calculateConfidence, updateRankings, finishRanking, handleUndo]);\n\n  // Around line 563, update the return statement:\n  // Around line 563, update the return statement to make backgrounds consistent\n  // Around line 563, update the return statement with solid background and texture\n  // Around line 563, clean return statement with solid background\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"min-h-screen bg-base-100 text-base-content font-sans\",\n    children: step === 'input' ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"min-h-screen flex flex-col items-center px-4\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        className: \"text-6xl font-crimson font-bold mt-12 mb-16 animate-fade-in\",\n        children: \"RankBoxd\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 729,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(InputForm, {\n        onSubmit: startRanking\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 732,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 728,\n      columnNumber: 7\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex flex-col min-h-screen\",\n      children: [/*#__PURE__*/_jsxDEV(ProgressBar, {\n        currentStep: step\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 736,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n        className: \"flex-grow\",\n        children: [step === 'mode-selection' && /*#__PURE__*/_jsxDEV(ModeSelection, {\n          movies: movies,\n          onModeSelect: selectMode\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 739,\n          columnNumber: 13\n        }, this), step === 'ranking' && memoizedRankingProcess, step === 'results' && /*#__PURE__*/_jsxDEV(MovieResults, {\n          rankings: Object.values(rankings),\n          calculateConfidence: calculateConfidence\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 746,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 737,\n        columnNumber: 9\n      }, this), (step === 'ranking' || step === 'results') && /*#__PURE__*/_jsxDEV(StatusBar, {\n        comparisons: comparisons,\n        maxComparisons: maxComparisons,\n        avgConfidence: Object.values(rankings).reduce((sum, r) => sum + calculateConfidence(r.movie.identifier), 0) / movies.length,\n        stabilityScore: calculateRankStability(),\n        estimatedMinutesLeft: Math.ceil((maxComparisons - comparisons) * 0.1)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 754,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 735,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 726,\n    columnNumber: 3\n  }, this);\n}\n_s(App, \"QGfhzU8YM/v6pS54GhwTz+LYsrY=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useMemo","InputForm","RankingProcess","MovieResults","ProgressBar","ModeSelection","StatusBar","jsxDEV","_jsxDEV","CONFIDENCE_SCALING","BASE_THRESHOLD","MIN_DATASET","MAX_DATASET","EARLY_STAGE_MULTIPLIER","LATE_STAGE_MULTIPLIER","MIN_ALLOWED_THRESHOLD","MAX_ALLOWED_THRESHOLD","CONFIDENCE_CONSTANTS","MIN_COMPARISONS","OPTIMAL_COMPARISONS","LOCAL_RANGE","RECENT_WEIGHT","HISTORICAL_WEIGHT","POSITION_WEIGHTS","TOP","MIDDLE","BOTTOM","TRANSITIVITY_WEIGHT","COMPARISON_QUALITY_WEIGHT","calculateAdaptiveThresholds","movieCount","progress","sizeFactor","Math","min","max","baseThreshold","progressMultiplier","adaptiveThreshold","confidence","stability","transitivity","rankChange","calculateLocalTransitivity","movieId","rankings","sortedMovies","position","localRange","start","end","length","localMovies","slice","weightedTransitivity","totalWeight","i","j","k","a","b","c","map","m","movie","identifier","posWeight","abs","ratingDiffs","rating","ratingWeight","weight","recentResults","some","r","opponent","calculateEnhancedConfidence","allMovies","record","comparisons","comparisonScore","Object","values","sort","findIndex","relativePosition","expectedWinRate","positionWeight","actualWinRate","wins","consistencyScore","neighbors","filter","id","localComparisons","includes","localConsistencyScore","reduce","sum","result","historicalResults","calculateResultsConsistency","results","flips","recentConsistency","historicalConsistency","temporalConsistency","transitivityScore","finalConfidence","calculateComparisonImpact","movieA","movieB","recordA","recordB","ratingDiff","avgComparisons","uncertaintyScore","ratingProximity","exp","phaseImportance","impactScore","App","_s","movies","setMovies","setRankings","step","setStep","setComparisons","maxComparisons","setMaxComparisons","pendingUpdates","setPendingUpdates","recentChanges","setRecentChanges","comparisonHistory","setComparisonHistory","movieMomentum","setMovieMomentum","isCurrentComparisonHighImpact","setIsCurrentComparisonHighImpact","CONVERGENCE_CHECK_WINDOW","BASE_LEARNING_RATE","VOLATILITY_WINDOW","VOLATILITY_THRESHOLD_HIGH","VOLATILITY_THRESHOLD_LOW","MOMENTUM_FACTOR","MIN_LEARNING_RATE","MAX_LEARNING_RATE","EARLY_TERMINATION","MIN_PROGRESS","MIN_COMPARISONS_PER_MOVIE","MIN_CONFIDENCE_THRESHOLD","STABILITY_WINDOW","STABILITY_THRESHOLD","MIN_TRANSITIVITY_SCORE","RELATIVE_RANK_STABILITY","calculateConfidence","calculateBatchParameters","scalingFactor","log2","baseSizes","EARLY_STAGE_SIZE","floor","MID_STAGE_SIZE","LATE_STAGE_SIZE","EARLY_STAGE_THRESHOLD","LATE_STAGE_THRESHOLD","calculateVolatility","recentVolatility","change","volatilityFactor","round","startRanking","movieList","console","log","initialRankings","acc","losses","confidenceScore","uncertainty","selectMode","mode","comparisonsCount","finishRanking","setTimeout","handleUndo","newHistory","lastComparison","pop","prev","pair","checkTransitivityViolation","winner","loser","winnerRating","loserRating","getDynamicLearningRate","winnerConfidence","loserConfidence","learningRate","surpriseFactor","confidenceFactor","winnerMomentum","loserMomentum","avgMomentum","calculateOptimalBatchSize","batchParams","avgConfidence","early","mid","late","toFixed","calculateTransitivityScore","transitiveTriads","totalTriads","sampleSize","idx1","random","idx2","idx3","x","y","calculateRankStability","currentRanking","previousRanking","stabilityScore","totalMovies","previousIndex","indexOf","maxPossibleDiff","actualDiff","positionStability","checkRankingStability","adaptiveThresholds","insufficientComparisons","recentInstability","rankStability","checkConvergence","processBatchUpdate","updates","prevRankings","newRankings","newMomentum","forEach","winnerStrength","loserStrength","expectedProbWinner","ratingChange","updateRankings","winnerIdentifier","loserIdentifier","currentPair","isHighImpact","newPending","optimalBatchSize","memoizedRankingProcess","onChoose","onFinish","onUndo","fileName","_jsxFileName","lineNumber","columnNumber","className","children","onSubmit","currentStep","onModeSelect","estimatedMinutesLeft","ceil","_c","$RefreshReg$"],"sources":["/Users/kilianreichl/RBDev/rankboxd/src/App.js"],"sourcesContent":["// App.js\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport InputForm from './components/InputForm';\nimport RankingProcess from './components/RankingProcess';\nimport MovieResults from './components/Results';\nimport ProgressBar from './components/ProgressBar';\nimport ModeSelection from './components/ModeSelection';\nimport StatusBar from './components/StatusBar';\n\nconst CONFIDENCE_SCALING = {\n  BASE_THRESHOLD: 0.7,\n  MIN_DATASET: 10,\n  MAX_DATASET: 500,\n  EARLY_STAGE_MULTIPLIER: 0.8,\n  LATE_STAGE_MULTIPLIER: 1.2,\n  MIN_ALLOWED_THRESHOLD: 0.5,\n  MAX_ALLOWED_THRESHOLD: 0.9\n};\n\nconst CONFIDENCE_CONSTANTS = {\n  MIN_COMPARISONS: 3,\n  OPTIMAL_COMPARISONS: 5,\n  LOCAL_RANGE: 3,\n  RECENT_WEIGHT: 0.6,\n  HISTORICAL_WEIGHT: 0.4,\n  POSITION_WEIGHTS: {\n    TOP: 0.8,    // Expect more consistent wins\n    MIDDLE: 0.5, // Mixed results are okay\n    BOTTOM: 0.8  // Expect more consistent losses\n  },\n  TRANSITIVITY_WEIGHT: 0.3,\n  COMPARISON_QUALITY_WEIGHT: 0.2\n};\n\nconst calculateAdaptiveThresholds = (movieCount, progress) => {\n  // Calculate base scaling factor based on dataset size\n  const sizeFactor = Math.min(Math.max(\n    (movieCount - CONFIDENCE_SCALING.MIN_DATASET) / \n    (CONFIDENCE_SCALING.MAX_DATASET - CONFIDENCE_SCALING.MIN_DATASET),\n    0\n  ), 1);\n  \n  // Adjust base threshold based on dataset size\n  // Smaller datasets need higher confidence thresholds\n  const baseThreshold = CONFIDENCE_SCALING.BASE_THRESHOLD * (1 - sizeFactor * 0.3);\n  \n  // Calculate progress-based thresholds\n  const progressMultiplier = progress < 0.3 ? \n    CONFIDENCE_SCALING.EARLY_STAGE_MULTIPLIER :\n    progress > 0.7 ? \n      CONFIDENCE_SCALING.LATE_STAGE_MULTIPLIER : \n      1;\n  \n  // Calculate final threshold with bounds\n  const adaptiveThreshold = Math.min(\n    Math.max(\n      baseThreshold * progressMultiplier,\n      CONFIDENCE_SCALING.MIN_ALLOWED_THRESHOLD\n    ),\n    CONFIDENCE_SCALING.MAX_ALLOWED_THRESHOLD\n  );\n\n  return {\n    confidence: adaptiveThreshold,\n    stability: adaptiveThreshold * 0.8,\n    transitivity: adaptiveThreshold * 0.9,\n    rankChange: Math.max(0.02, 0.05 * (1 - sizeFactor))\n  };\n};\n\nconst calculateLocalTransitivity = (movieId, rankings, sortedMovies, position) => {\n  const localRange = CONFIDENCE_CONSTANTS.LOCAL_RANGE;\n  const start = Math.max(0, position - localRange);\n  const end = Math.min(sortedMovies.length, position + localRange + 1);\n  const localMovies = sortedMovies.slice(start, end);\n  \n  let weightedTransitivity = 0;\n  let totalWeight = 0;\n  \n  for (let i = 0; i < localMovies.length - 2; i++) {\n    for (let j = i + 1; j < localMovies.length - 1; j++) {\n      for (let k = j + 1; k < localMovies.length; k++) {\n        const [a, b, c] = [localMovies[i], localMovies[j], localMovies[k]]\n          .map(m => m.movie.identifier);\n          \n        // Calculate positional weight (closer positions matter more)\n        const posWeight = 1 / (Math.abs(position - i) + 1);\n        \n        // Calculate rating difference weight\n        const ratingDiffs = Math.abs(rankings[a].rating - rankings[b].rating) +\n                          Math.abs(rankings[b].rating - rankings[c].rating) +\n                          Math.abs(rankings[a].rating - rankings[c].rating);\n        const ratingWeight = 1 / (1 + ratingDiffs);\n        \n        const weight = posWeight * ratingWeight;\n        \n        if (rankings[a].recentResults.some(r => r.opponent === b || r.opponent === c) &&\n            rankings[b].recentResults.some(r => r.opponent === c)) {\n          totalWeight += weight;\n          if ((rankings[a].rating > rankings[b].rating && \n               rankings[b].rating > rankings[c].rating && \n               rankings[a].rating > rankings[c].rating) ||\n              (rankings[c].rating > rankings[b].rating && \n               rankings[b].rating > rankings[a].rating && \n               rankings[c].rating > rankings[a].rating)) {\n            weightedTransitivity += weight;\n          }\n        }\n      }\n    }\n  }\n  \n  return totalWeight > 0 ? weightedTransitivity / totalWeight : 0.5;\n};\n\nconst calculateEnhancedConfidence = (movieId, rankings, allMovies) => {\n  const record = rankings[movieId];\n  if (!record || record.comparisons < CONFIDENCE_CONSTANTS.MIN_COMPARISONS) {\n    return 0.2; // Minimum baseline confidence of 20%\n  }\n\n  // 1. Base Comparison Confidence (0-1)\n  const comparisonScore = Math.min(\n    record.comparisons / CONFIDENCE_CONSTANTS.OPTIMAL_COMPARISONS,\n    1\n  ) * 0.8 + 0.2; // Minimum 20% if at least MIN_COMPARISONS\n\n  // 2. Position-Aware Consistency (0-1)\n  const sortedMovies = Object.values(rankings).sort((a, b) => b.rating - a.rating);\n  const position = sortedMovies.findIndex(r => r.movie.identifier === movieId);\n  const relativePosition = position / sortedMovies.length;\n\n  let expectedWinRate, positionWeight;\n    if (relativePosition <= 0.25) {\n      expectedWinRate = 0.75; // Top 25% should win most\n      positionWeight = CONFIDENCE_CONSTANTS.POSITION_WEIGHTS.TOP;\n    } else if (relativePosition >= 0.75) {\n      expectedWinRate = 0.25; // Bottom 25% should lose most\n      positionWeight = CONFIDENCE_CONSTANTS.POSITION_WEIGHTS.BOTTOM;\n    } else {\n      expectedWinRate = 0.5; // Middle 50% can be mixed\n      positionWeight = CONFIDENCE_CONSTANTS.POSITION_WEIGHTS.MIDDLE;\n    }\n\n  const actualWinRate = record.wins / record.comparisons;\n  const consistencyScore = (1 - Math.abs(actualWinRate - expectedWinRate)) * positionWeight;\n\n  // 3. Local Performance (0-1)\n  const neighbors = sortedMovies\n    .slice(\n      Math.max(0, position - CONFIDENCE_CONSTANTS.LOCAL_RANGE),\n      Math.min(sortedMovies.length, position + CONFIDENCE_CONSTANTS.LOCAL_RANGE + 1)\n    )\n    .map(r => r.movie.identifier)\n    .filter(id => id !== movieId);\n\n  const localComparisons = record.recentResults.filter(r => \n    neighbors.includes(r.opponent)\n  );\n  \n  const localConsistencyScore = localComparisons.length > 0\n    ? localComparisons.reduce((sum, r) => \n        sum + (r.result === (r.opponent.rating < record.rating ? 1 : 0)), \n        0\n      ) / localComparisons.length\n    : 0.5;\n\n  // 4. Temporal Confidence (0-1)\n  const recentResults = record.recentResults.slice(-5);\n  const historicalResults = record.recentResults.slice(0, -5);\n  \n  const calculateResultsConsistency = results => {\n    if (results.length < 2) return 0.5;\n    let flips = 0;\n    for (let i = 1; i < results.length; i++) {\n      if (results[i].result !== results[i-1].result) flips++;\n    }\n    return 1 - (flips / (results.length - 1));\n  };\n\n  const recentConsistency = calculateResultsConsistency(recentResults);\n  const historicalConsistency = calculateResultsConsistency(historicalResults);\n  \n  const temporalConsistency = \n    (recentConsistency * CONFIDENCE_CONSTANTS.RECENT_WEIGHT) +\n    (historicalConsistency * CONFIDENCE_CONSTANTS.HISTORICAL_WEIGHT);\n\n  // 5. Transitivity Score (0-1)\n  const transitivityScore = calculateLocalTransitivity(\n    movieId, \n    rankings, \n    sortedMovies, \n    position\n  );\n\n  // Combine all factors with weights\n  const finalConfidence = (\n    comparisonScore * 0.25 +\n    consistencyScore * 0.20 +\n    localConsistencyScore * 0.25 +\n    temporalConsistency * 0.15 +\n    transitivityScore * CONFIDENCE_CONSTANTS.TRANSITIVITY_WEIGHT\n  );\n\n  // Ensure minimum confidence of 20% and maximum of 100%\n  return Math.min(Math.max(finalConfidence, 0.2), 1);\n};\n\nconst calculateComparisonImpact = (movieA, movieB, rankings, progress) => {\n  // Don't show impact indicators too early\n  if (progress < 0.2) return false;\n\n  const recordA = rankings[movieA.identifier];\n  const recordB = rankings[movieB.identifier];\n  \n  // Calculate rating uncertainty\n  const ratingDiff = Math.abs(recordA.rating - recordB.rating);\n  const avgComparisons = (recordA.comparisons + recordB.comparisons) / 2;\n  const uncertaintyScore = 1 / (avgComparisons + 1);\n  \n  // More impactful if:\n  // 1. Movies are close in rating\n  // 2. We don't have many comparisons yet\n  // 3. We're in the middle phase of ranking (20%-80%)\n  const ratingProximity = 1 / (1 + Math.exp(5 * (ratingDiff - 0.5)));\n  const phaseImportance = 1 - Math.abs(progress - 0.5) * 2;\n  \n  const impactScore = (\n    ratingProximity * 0.5 +\n    uncertaintyScore * 0.3 +\n    phaseImportance * 0.2\n  );\n\n  // Return true if this is a high-impact comparison\n  return impactScore > 0.7;\n};\n\nfunction App() {\n  const [movies, setMovies] = useState([]);\n  const [rankings, setRankings] = useState({});\n  const [step, setStep] = useState('input');\n  const [comparisons, setComparisons] = useState(0);\n  const [maxComparisons, setMaxComparisons] = useState(0);\n  const [pendingUpdates, setPendingUpdates] = useState([]);\n  const [recentChanges, setRecentChanges] = useState([]);\n  const [comparisonHistory, setComparisonHistory] = useState([]);\n  const [movieMomentum, setMovieMomentum] = useState({});\n  const [isCurrentComparisonHighImpact, setIsCurrentComparisonHighImpact] = useState(false);\n\n  const CONVERGENCE_CHECK_WINDOW = 10;\n  const BASE_LEARNING_RATE = 0.1;\n\n  const VOLATILITY_WINDOW = 20; // How many recent changes to consider\n  const VOLATILITY_THRESHOLD_HIGH = 0.05; // High volatility threshold\n  const VOLATILITY_THRESHOLD_LOW = 0.01; // Low volatility threshold\n\n  const MOMENTUM_FACTOR = 0.9;\n  const MIN_LEARNING_RATE = 0.01;\n  const MAX_LEARNING_RATE = 0.2;\n\n  const EARLY_TERMINATION = {\n    MIN_PROGRESS: 0.4, // Don't terminate before 40% completion\n    MIN_COMPARISONS_PER_MOVIE: 5,\n    MIN_CONFIDENCE_THRESHOLD: 0.7,\n    STABILITY_WINDOW: 15,\n    STABILITY_THRESHOLD: 0.03,\n    MIN_TRANSITIVITY_SCORE: 0.85,\n    RELATIVE_RANK_STABILITY: 0.9\n  };\n\n  const calculateConfidence = useCallback((movieId) => {\n    return calculateEnhancedConfidence(movieId, rankings, movies);\n  }, [rankings, movies]);\n\n  const calculateBatchParameters = useCallback((movieCount) => {\n    const scalingFactor = Math.log2(movieCount) / Math.log2(100);\n  \n    // Calculate base sizes\n    const baseSizes = {\n      EARLY_STAGE_SIZE: Math.min(8, Math.max(2, Math.floor(movieCount * 0.03 * scalingFactor))),\n      MID_STAGE_SIZE: Math.min(12, Math.max(3, Math.floor(movieCount * 0.06 * scalingFactor))),\n      LATE_STAGE_SIZE: Math.min(20, Math.max(4, Math.floor(movieCount * 0.1 * scalingFactor))),\n      EARLY_STAGE_THRESHOLD: 0.15 + (0.05 * (1 - scalingFactor)),\n      LATE_STAGE_THRESHOLD: 0.65 + (0.1 * scalingFactor),\n      MIN_CONFIDENCE_THRESHOLD: 0.35 + (0.1 * scalingFactor)\n    };\n    \n    // Calculate volatility factor based on recent rating changes\n    const calculateVolatility = () => {\n      if (recentChanges.length < VOLATILITY_WINDOW) {\n        return 1; // Default to normal batch size if not enough data\n      }\n  \n      // Calculate average magnitude of recent rating changes\n      const recentVolatility = recentChanges\n        .slice(-VOLATILITY_WINDOW)\n        .reduce((sum, change) => sum + Math.abs(change), 0) / VOLATILITY_WINDOW;\n  \n      // Convert volatility to a scaling factor between 0.5 and 1.5\n      if (recentVolatility > VOLATILITY_THRESHOLD_HIGH) {\n        return 0.5; // High volatility = smaller batches\n      } else if (recentVolatility < VOLATILITY_THRESHOLD_LOW) {\n        return 1.5; // Low volatility = larger batches\n      } else {\n        // Linear interpolation between thresholds\n        return 1 + ((VOLATILITY_THRESHOLD_HIGH - recentVolatility) / \n                    (VOLATILITY_THRESHOLD_HIGH - VOLATILITY_THRESHOLD_LOW));\n      }\n    };\n  \n    const volatilityFactor = calculateVolatility();\n    \n    // Apply volatility factor to batch sizes\n    return {\n      ...baseSizes,\n      EARLY_STAGE_SIZE: Math.max(2, Math.round(baseSizes.EARLY_STAGE_SIZE * volatilityFactor)),\n      MID_STAGE_SIZE: Math.max(3, Math.round(baseSizes.MID_STAGE_SIZE * volatilityFactor)),\n      LATE_STAGE_SIZE: Math.max(4, Math.round(baseSizes.LATE_STAGE_SIZE * volatilityFactor))\n    };\n  }, [recentChanges]);\n\n  const startRanking = useCallback((movieList) => {\n    console.log(`Starting ranking process with ${movieList.length} movies`);\n    const initialRankings = movieList.reduce((acc, movie) => {\n      acc[movie.identifier] = {\n        rating: 0,\n        movie: movie,\n        wins: 0,\n        losses: 0,\n        comparisons: 0,\n        recentResults: [], // Will store objects with opponent and result info\n        confidenceScore: 0,\n        uncertainty: 0\n      };\n      return acc;\n    }, {});\n    setMovies(movieList);\n    setRankings(initialRankings);\n    setStep('mode-selection');\n  }, []);\n\n  const selectMode = (mode, comparisonsCount) => {\n    setMaxComparisons(comparisonsCount);\n    setStep('ranking');\n  };\n\n  const finishRanking = useCallback(() => {\n    console.log(\"Finishing ranking process\");\n    setTimeout(() => {\n      setStep('results');\n    }, 0);\n  }, []);\n\n  const handleUndo = useCallback(() => {\n    if (comparisonHistory.length > 0) {\n      const newHistory = [...comparisonHistory];\n      const lastComparison = newHistory.pop();\n      setComparisonHistory(newHistory);\n      setComparisons(prev => Math.max(0, prev - 1));\n      \n      // Clear any pending updates\n      setPendingUpdates([]);\n      \n      // Reset the rankings to the previous state and provide the previous pair\n      if (lastComparison) {\n        setRankings(lastComparison.rankings);\n        // Reset recent changes since we're going back\n        setRecentChanges([]);\n        return lastComparison.pair; // Return the previous pair\n      }\n    }\n    return null;\n  }, [comparisonHistory]);\n  \n  const checkTransitivityViolation = useCallback((winner, loser) => {\n    const winnerRating = rankings[winner].rating;\n    const loserRating = rankings[loser].rating;\n    \n    // If the winner's current rating is lower, this is a transitivity violation\n    if (winnerRating < loserRating) {\n      console.log(`Transitivity violation detected: ${winner} (${winnerRating}) beat ${loser} (${loserRating})`);\n      return true;\n    }\n    return false;\n  }, [rankings]);\n\n  const getDynamicLearningRate = useCallback((winner, loser) => {\n    const progress = comparisons / maxComparisons;\n    const ratingDiff = Math.abs(rankings[winner].rating - rankings[loser].rating);\n    const winnerConfidence = calculateConfidence(winner);\n    const loserConfidence = calculateConfidence(loser);\n    \n    // Start with base learning rate\n    let learningRate = BASE_LEARNING_RATE;\n    \n    // Adjust based on progress\n    learningRate *= (1 - progress * 0.5);\n    \n    // Adjust for rating difference\n    const surpriseFactor = 1 / (1 + Math.exp(-5 * (1 - ratingDiff)));\n    learningRate *= (1 + surpriseFactor);\n    \n    // Confidence adjustment\n    const confidenceFactor = 1 - (winnerConfidence + loserConfidence) / 4;\n    learningRate *= confidenceFactor;\n    \n    // Transitivity violation adjustment\n    if (checkTransitivityViolation(winner, loser)) {\n      learningRate *= 1.5;\n    }\n    \n    // Apply momentum if available\n    const winnerMomentum = movieMomentum[winner] || 0;\n    const loserMomentum = movieMomentum[loser] || 0;\n    const avgMomentum = (Math.abs(winnerMomentum) + Math.abs(loserMomentum)) / 2;\n    learningRate *= (1 + avgMomentum * MOMENTUM_FACTOR);\n    \n    // Clamp learning rate\n    return Math.max(MIN_LEARNING_RATE, Math.min(MAX_LEARNING_RATE, learningRate));\n  }, [comparisons, maxComparisons, rankings, checkTransitivityViolation, calculateConfidence, movieMomentum]);\n  \n  const calculateOptimalBatchSize = useCallback(() => {\n    const movieCount = movies.length;\n    const batchParams = calculateBatchParameters(movieCount);\n    const progress = comparisons / maxComparisons;\n    \n    // Calculate average confidence across all movies\n    const avgConfidence = Object.values(rankings).reduce((sum, record) => {\n      return sum + (record && record.movie ? calculateConfidence(record.movie.identifier) : 0);\n    }, 0) / movieCount;\n  \n    console.log(`Current batch parameters for ${movieCount} movies:`, {\n      early: batchParams.EARLY_STAGE_SIZE,\n      mid: batchParams.MID_STAGE_SIZE,\n      late: batchParams.LATE_STAGE_SIZE,\n      progress: progress.toFixed(2),\n      avgConfidence: avgConfidence.toFixed(2)\n    });\n  \n    // Determine stage based on progress\n    if (progress < batchParams.EARLY_STAGE_THRESHOLD) {\n      return batchParams.EARLY_STAGE_SIZE;\n    } else if (progress > batchParams.LATE_STAGE_THRESHOLD) {\n      return batchParams.LATE_STAGE_SIZE;\n    } else {\n      return avgConfidence < batchParams.MIN_CONFIDENCE_THRESHOLD \n        ? batchParams.EARLY_STAGE_SIZE \n        : batchParams.MID_STAGE_SIZE;\n    }\n      }, [\n        movies.length, \n        comparisons, \n        maxComparisons, \n        rankings, \n        calculateConfidence,  // Add this\n        calculateBatchParameters\n      ]);\n  \n\n  const calculateTransitivityScore = useCallback(() => {\n    let transitiveTriads = 0;\n    let totalTriads = 0;\n  \n    // Get sorted movies by rating\n    const sortedMovies = Object.values(rankings)\n      .sort((a, b) => b.rating - a.rating)\n      .map(r => r.movie.identifier);\n  \n    // Check random sample of triads for transitivity\n    const sampleSize = Math.min(1000, Math.floor(sortedMovies.length * (sortedMovies.length - 1) * (sortedMovies.length - 2) / 6));\n    \n    for (let i = 0; i < sampleSize; i++) {\n      const idx1 = Math.floor(Math.random() * sortedMovies.length);\n      const idx2 = Math.floor(Math.random() * sortedMovies.length);\n      const idx3 = Math.floor(Math.random() * sortedMovies.length);\n      \n      if (idx1 !== idx2 && idx2 !== idx3 && idx1 !== idx3) {\n        totalTriads++;\n        const [a, b, c] = [sortedMovies[idx1], sortedMovies[idx2], sortedMovies[idx3]].sort(\n          (x, y) => rankings[y].rating - rankings[x].rating\n        );\n        \n        if (rankings[a].rating > rankings[b].rating && \n            rankings[b].rating > rankings[c].rating && \n            rankings[a].rating > rankings[c].rating) {\n          transitiveTriads++;\n        }\n      }\n    }\n  \n    return totalTriads > 0 ? transitiveTriads / totalTriads : 0;\n  }, [rankings]);\n  \n  const calculateRankStability = useCallback(() => {\n    if (comparisonHistory.length < EARLY_TERMINATION.STABILITY_WINDOW) {\n      return 0;\n    }\n\n    const currentRanking = Object.values(rankings)\n      .sort((a, b) => b.rating - a.rating)\n      .map(r => r.movie.identifier);\n\n    const previousRanking = Object.values(\n      comparisonHistory[comparisonHistory.length - EARLY_TERMINATION.STABILITY_WINDOW].rankings\n    )\n      .sort((a, b) => b.rating - a.rating)\n      .map(r => r.movie.identifier);\n\n    let stabilityScore = 0;\n    const totalMovies = currentRanking.length;\n\n    for (let i = 0; i < totalMovies; i++) {\n      const previousIndex = previousRanking.indexOf(currentRanking[i]);\n      const positionWeight = 1 - (i / totalMovies); // Top positions matter more\n      const maxPossibleDiff = totalMovies - 1;\n      const actualDiff = Math.abs(i - previousIndex);\n      const positionStability = 1 - (actualDiff / maxPossibleDiff);\n      stabilityScore += positionStability * positionWeight;\n    }\n\n    return stabilityScore / totalMovies;\n  }, [rankings, comparisonHistory, EARLY_TERMINATION.STABILITY_WINDOW]);\n\n  const checkRankingStability = useCallback(() => {\n    const progress = comparisons / maxComparisons;\n    const adaptiveThresholds = calculateAdaptiveThresholds(movies.length, progress);\n    \n    // Don't check before minimum progress\n    if (comparisons / maxComparisons < EARLY_TERMINATION.MIN_PROGRESS) {\n      return false;\n    }\n  \n    // Check minimum comparisons per movie\n    const insufficientComparisons = Object.values(rankings).some(\n      record => record.comparisons < EARLY_TERMINATION.MIN_COMPARISONS_PER_MOVIE\n    );\n    if (insufficientComparisons) {\n      return false;\n    }\n  \n    // Calculate average confidence with adaptive threshold\n    const avgConfidence = Object.values(rankings).reduce(\n      (sum, record) => sum + calculateConfidence(record.movie.identifier),\n      0\n    ) / movies.length;\n    if (avgConfidence < Math.max(adaptiveThresholds.confidence, EARLY_TERMINATION.MIN_CONFIDENCE_THRESHOLD)) {\n      return false;\n    }\n  \n    // Check recent stability with adaptive threshold\n    if (recentChanges.length < EARLY_TERMINATION.STABILITY_WINDOW) {\n      return false;\n    }\n    const recentInstability = recentChanges\n      .slice(-EARLY_TERMINATION.STABILITY_WINDOW)\n      .some(change => Math.abs(change) > Math.min(adaptiveThresholds.rankChange, EARLY_TERMINATION.STABILITY_THRESHOLD));\n    if (recentInstability) {\n      return false;\n    }\n  \n    // Check transitivity with adaptive threshold\n    const transitivityScore = calculateTransitivityScore();\n    if (transitivityScore < Math.max(adaptiveThresholds.transitivity, EARLY_TERMINATION.MIN_TRANSITIVITY_SCORE)) {\n      return false;\n    }\n  \n    // Check relative rank stability with adaptive threshold\n    const rankStability = calculateRankStability();\n    if (rankStability < Math.max(adaptiveThresholds.stability, EARLY_TERMINATION.RELATIVE_RANK_STABILITY)) {\n      return false;\n    }\n  \n    console.log('Early termination conditions met:', {\n      progress: (comparisons / maxComparisons).toFixed(2),\n      avgConfidence: avgConfidence.toFixed(2),\n      transitivityScore: transitivityScore.toFixed(2),\n      rankStability: rankStability.toFixed(2),\n      adaptiveThresholds: {\n        confidence: adaptiveThresholds.confidence.toFixed(2),\n        stability: adaptiveThresholds.stability.toFixed(2),\n        transitivity: adaptiveThresholds.transitivity.toFixed(2),\n        rankChange: adaptiveThresholds.rankChange.toFixed(3)\n      }\n    });\n  \n    return true;\n  }, [\n    movies.length,\n    comparisons,\n    maxComparisons,\n    rankings,\n    recentChanges,\n    calculateConfidence,\n    calculateTransitivityScore,\n    calculateRankStability,\n    EARLY_TERMINATION.MIN_PROGRESS,\n    EARLY_TERMINATION.MIN_COMPARISONS_PER_MOVIE,\n    EARLY_TERMINATION.MIN_CONFIDENCE_THRESHOLD,\n    EARLY_TERMINATION.STABILITY_WINDOW,\n    EARLY_TERMINATION.STABILITY_THRESHOLD,\n    EARLY_TERMINATION.MIN_TRANSITIVITY_SCORE,\n    EARLY_TERMINATION.RELATIVE_RANK_STABILITY\n  ]);\n\nconst checkConvergence = useCallback(() => {\n  if (checkRankingStability()) {\n    console.log(\"Rankings have converged with high confidence - finishing early\");\n    finishRanking();\n  }\n}, [checkRankingStability, finishRanking]);\n\nconst processBatchUpdate = useCallback((updates) => {\n  setRankings(prevRankings => {\n    const newRankings = { ...prevRankings };\n    const newMomentum = { ...movieMomentum };\n    \n    updates.forEach(({ winner, loser }) => {\n      const learningRate = getDynamicLearningRate(winner, loser);\n      \n      const winnerStrength = Math.exp(prevRankings[winner].rating);\n      const loserStrength = Math.exp(prevRankings[loser].rating);\n      \n      const expectedProbWinner = winnerStrength / (winnerStrength + loserStrength);\n      const ratingChange = learningRate * (1 - expectedProbWinner);\n      \n      // Update momentum\n      newMomentum[winner] = (newMomentum[winner] || 0) * MOMENTUM_FACTOR + ratingChange;\n      newMomentum[loser] = (newMomentum[loser] || 0) * MOMENTUM_FACTOR - ratingChange;\n      \n      // Update ratings with momentum influence and store opponent info\n      newRankings[winner] = {\n        ...newRankings[winner],\n        rating: prevRankings[winner].rating + ratingChange + newMomentum[winner] * MOMENTUM_FACTOR,\n        wins: prevRankings[winner].wins + 1,\n        comparisons: prevRankings[winner].comparisons + 1,\n        recentResults: [...prevRankings[winner].recentResults.slice(-9), {\n          opponent: loser,\n          result: 1,\n          ratingDiff: Math.abs(prevRankings[winner].rating - prevRankings[loser].rating)\n        }]\n      };\n      \n      newRankings[loser] = {\n        ...newRankings[loser],\n        rating: prevRankings[loser].rating - ratingChange + newMomentum[loser] * MOMENTUM_FACTOR,\n        losses: prevRankings[loser].losses + 1,\n        comparisons: prevRankings[loser].comparisons + 1,\n        recentResults: [...prevRankings[loser].recentResults.slice(-9), {\n          opponent: winner,\n          result: 0,\n          ratingDiff: Math.abs(prevRankings[winner].rating - prevRankings[loser].rating)\n        }]\n      };\n      \n      setRecentChanges(prev => [...prev.slice(-CONVERGENCE_CHECK_WINDOW + 1), ratingChange]);\n    });\n    \n    setMovieMomentum(newMomentum);\n    return newRankings;\n  });\n  \n  checkConvergence();\n}, [getDynamicLearningRate, checkConvergence, movieMomentum]);\n\nconst updateRankings = useCallback((winnerIdentifier, loserIdentifier, currentPair) => {\n    // Save current state to history\n    setComparisonHistory(prev => [...prev, {\n      winner: winnerIdentifier,\n      loser: loserIdentifier,\n      rankings: { ...rankings },\n      pair: currentPair  // Use currentPair instead of pair\n    }]);\n\n    // Calculate progress for impact determination\n    const progress = comparisons / maxComparisons;\n    \n    // Calculate impact before updating rankings\n    const isHighImpact = calculateComparisonImpact(\n      rankings[winnerIdentifier], \n      rankings[loserIdentifier],\n      rankings,\n      progress\n    );\n\n    // Add to pending updates and process if optimal batch size reached\n    setPendingUpdates(prev => {\n      const newPending = [...prev, { winner: winnerIdentifier, loser: loserIdentifier }];\n      const optimalBatchSize = calculateOptimalBatchSize();\n      \n      if (newPending.length >= optimalBatchSize) {\n        console.log(`Processing batch of size ${optimalBatchSize}`);\n        processBatchUpdate(newPending);\n        return [];\n      }\n      return newPending;\n    });\n\n    setComparisons(prev => prev + 1);\n  }, [rankings, processBatchUpdate, calculateOptimalBatchSize, comparisons, maxComparisons]);\n\n  useEffect(() => {\n    if (step === 'results' && pendingUpdates.length > 0) {\n      processBatchUpdate(pendingUpdates);\n      setPendingUpdates([]);\n    }\n  }, [step, pendingUpdates, processBatchUpdate]);\n\n  const memoizedRankingProcess = useMemo(() => (\n    <RankingProcess \n      movies={movies} \n      rankings={rankings}\n      comparisons={comparisons}\n      maxComparisons={maxComparisons}\n      calculateConfidence={calculateConfidence}\n      onChoose={updateRankings} \n      onFinish={finishRanking}\n      onUndo={handleUndo}\n    />\n  ), [movies, rankings, comparisons, maxComparisons, calculateConfidence, updateRankings, finishRanking, handleUndo]);\n\n  // Around line 563, update the return statement:\n// Around line 563, update the return statement to make backgrounds consistent\n// Around line 563, update the return statement with solid background and texture\n// Around line 563, clean return statement with solid background\nreturn (\n  <div className=\"min-h-screen bg-base-100 text-base-content font-sans\">\n    {step === 'input' ? (\n      <div className=\"min-h-screen flex flex-col items-center px-4\">\n        <h1 className=\"text-6xl font-crimson font-bold mt-12 mb-16 animate-fade-in\">\n          RankBoxd\n        </h1>\n        <InputForm onSubmit={startRanking} />\n      </div>\n    ) : (\n      <div className=\"flex flex-col min-h-screen\">\n        <ProgressBar currentStep={step} />\n        <main className=\"flex-grow\">\n          {step === 'mode-selection' && (\n            <ModeSelection \n              movies={movies} \n              onModeSelect={selectMode}\n            />\n          )}\n          {step === 'ranking' && memoizedRankingProcess}\n          {step === 'results' && (\n            <MovieResults\n              rankings={Object.values(rankings)}\n              calculateConfidence={calculateConfidence}\n            />\n          )}\n        </main>\n        \n        {(step === 'ranking' || step === 'results') && (\n          <StatusBar\n            comparisons={comparisons}\n            maxComparisons={maxComparisons}\n            avgConfidence={Object.values(rankings).reduce((sum, r) => sum + calculateConfidence(r.movie.identifier), 0) / movies.length}\n            stabilityScore={calculateRankStability()}\n            estimatedMinutesLeft={Math.ceil((maxComparisons - comparisons) * 0.1)}\n          />\n        )}\n      </div>\n    )}\n  </div>\n);\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}